<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		JUC并发编程 | 
	 
	小德的博客
	</title>
	
	<!-- keywords,description -->
	
		<meta name="keywords" content="小德的博客" />
	 
		<meta name="description" content="小德的博客" />
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.4.14/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">小德的博客</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	
		<li class="menu-item">
			<a href="/tags" class="menu-item-link">标签</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/wujun234" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										JAVA学习
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java框架
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/ElasticSearch/">
                     
										    ElasticSearch
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/MyBatisPlus/">
                     
										    MyBatisPlus
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/Mybatis/">
                     
										    Mybatis
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/Ngnix/">
                     
										    Ngnix
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/NoSQL/">
                     
										    NoSQL
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/Redis/">
                     
										    Redis
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/SSM/">
                     
										    SSM
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/Swagger/">
                     
										    Swagger
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E6%A1%86%E6%9E%B6/%E5%B7%A5%E5%85%B7/">
                     
										    工具
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java理论
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E7%90%86%E8%AE%BA/RBAC%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/">
                     
										    RBAC权限系统
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E7%90%86%E8%AE%BA/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">
                     
										    设计原则
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E7%90%86%E8%AE%BA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                     
										    设计模式
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java高级
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E9%AB%98%E7%BA%A7/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
                     
										    JUC并发编程
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E9%AB%98%E7%BA%A7/JVM/">
                     
										    JVM
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E9%AB%98%E7%BA%A7/Java%E5%8F%8D%E5%B0%84/">
                     
										    Java反射
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E9%AB%98%E7%BA%A7/Java%E6%B3%A8%E8%A7%A3/">
                     
										    Java注解
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E9%AB%98%E7%BA%A7/%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/">
                     
										    泛型的理解
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										其他
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%A0%E5%8E%BB%E5%A4%96%E5%8C%85%E5%85%AC%E5%8F%B8%EF%BC%9F/">
                     
										    为什么我不建议你去外包公司？
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96/%E9%AB%98%E6%95%B0/">
                     
										    高数
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										前端
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF/vue/">
                     
										    vue
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										理财
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%B4%A2/%E7%90%86%E8%B4%A2/">
                     
										    理财
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										算法与数据结构
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%89/">
                     
										    大O表示法（复杂度分析）
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                     
										    数据结构与算法
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/">
                     
										    队列
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%972/">
                     
										    队列2
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										项目管理
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Git/">
                     
										    Git
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/Jekins/">
                     
										    Jekins
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/SVN/">
                     
										    SVN
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										动画
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/%E5%8A%A8%E7%94%BB/Blender%E6%93%8D%E4%BD%9C/">
                     
										    Blender操作
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										测试
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/%E6%B5%8B%E8%AF%95/BUG/">
                     
										    BUG
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/%E6%B5%8B%E8%AF%95/Linux/">
                     
										    Linux
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/%E6%B5%8B%E8%AF%95/TCPIP%E7%90%86%E8%AE%BA/">
                     
										    TCPIP理论
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/%E6%B5%8B%E8%AF%95/%E4%BB%80%E4%B9%88%E6%98%AFPOP3%E3%80%81SMTP%E5%92%8CIMAP/">
                     
										    什么是POP3、SMTP和IMAP
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										阿里
									</a>
									
							<ul>
								<li class="file">
									<a href="/2021/12/02/%E9%98%BF%E9%87%8C/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E8%BF%99%E7%BE%A4%E7%96%AF%E5%AD%90/">
                     
										    阿里云的这群疯子
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/%E9%98%BF%E9%87%8C/%E9%98%BF%E9%87%8C%E7%AC%AC%E4%B8%80%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E2%80%94%E2%80%94%E5%A4%9A%E9%9A%86/">
                     
										    阿里第一位程序员——多隆
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2021/12/02/%E9%98%BF%E9%87%8C/%E9%98%BF%E9%87%8C%E8%81%8C%E7%BA%A7%E4%BD%93%E7%B3%BB/">
                     
										    阿里职级体系
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">
	JUC并发编程
</h1>
<div class="article-meta">
	
	<span>小德</span>
	<span>2021-12-02 12:57:59</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true">
                        <a href="/categories/java高级/">java高级</a>
                        </i>
                      
                    </span>
                
            
    

    
		<span>Tags：</span>
            
                
                    <span>
                        <i class="fa fa-tag" aria-hidden="true">
                        <a href="/tags/java高级/">java高级</a>
                        </i>
                    </span>
                
            
    
		</div>

</div>

<div id="article-content">
	<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h3 id="1-什么是JUC？"><a href="#1-什么是JUC？" class="headerlink" title="1.什么是JUC？"></a>1.什么是JUC？</h3><blockquote>
<p> Java.util.Concurrent</p>
</blockquote>
<p>Runnable没有返回值，效率比Callable低!</p>
<h3 id="2-线程和进程"><a href="#2-线程和进程" class="headerlink" title="2.线程和进程"></a>2.线程和进程</h3><blockquote>
<p>进程：一个程序</p>
</blockquote>
<p>一个进程往往可以包括多个线程，至少包括一个。</p>
<p>java默认有两个进程：main和GC</p>
<blockquote>
<p>线程：开了一个进程，Typora写字，自动保存（线程负责）</p>
</blockquote>
<p>对于java而言，Thread、Runnable、Callable</p>
<p><strong>java真的可以开启线程吗？不能，只能通过本地方法去调用底层的C++，无法直接操作。</strong></p>
<h3 id="3-并发、并行"><a href="#3-并发、并行" class="headerlink" title="3.并发、并行"></a>3.并发、并行</h3><blockquote>
<p>并发、并行</p>
</blockquote>
<p>并发（多线程操作同一个资源）：</p>
<p>CPU一核，模拟出多条线程，快速交替。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取CPU的核数</span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure>

<p><strong>并发编程的本质：充分利用CPU的资源</strong></p>
<p>并行（多个人一起走）</p>
<p>CPU多核，多个线程可以同时执行，线程池。</p>
<h3 id="4-线程有六个状态"><a href="#4-线程有六个状态" class="headerlink" title="4.线程有六个状态"></a>4.线程有六个状态</h3><p>创建、运行、阻塞、等待、超时等待、终止</p>
<blockquote>
<p>wait/sleep的区别</p>
</blockquote>
<p>1.来自不同的类，wait是Object类，sleep是Thread类</p>
<p>2.关于锁的释放，wait会释放锁，sleep不会释放锁</p>
<p>3.使用的范围不同，wait必须在同步代码块中，sleep可以任何地方使用</p>
<p>4.是否需要捕获异常，wait不需要捕获异常，sleep必须捕获异常</p>
<h3 id="5-Lock锁（重点）"><a href="#5-Lock锁（重点）" class="headerlink" title="5.Lock锁（重点）"></a>5.Lock锁（重点）</h3><blockquote>
<p>传统的synchronized</p>
</blockquote>
<p>线程就是一个单独的资源类，没有任何的附属操作<br>并发：多线程操作同一个资源,把资源丢到线程<br>jdk1.8 lambda表达式   ()-&gt;{}</p>
<p>Lock接口，实现类：可重用锁ReentrantLock、读锁，写锁</p>
<p>ReentrantLock源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁：先来后到</p>
<p>非公平锁：可以插队（默认）</p>
<p>1.new ReentrantLock</p>
<p>2.加锁 lock.lock()</p>
<p>3.解锁 lock.unlock();</p>
<p><strong>Lock锁和synchronized区别：</strong></p>
<p>1.synchronize是内置的java关键字，Lock是java类</p>
<p>2.synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁</p>
<p>3.synchronized会自动释放锁，Lock锁必须要手动释放锁，不释放会导致死锁</p>
<p>4.synchronized线程1（获得锁，阻塞），线程2（等待，傻傻的等），Lock锁的线程2就不一定等待下去</p>
<p><strong>lock.trylock():尝试获取锁</strong></p>
<p>5.synchronized可重入锁，不可中断，非公平的；Lock可重入锁，可以判断锁，非公平（可以自己设置）</p>
<p>6.synchronized适合少量的代码同步问题，Lock适合锁大量的同步代码</p>
<blockquote>
<p>锁是什么，如何判断锁的是谁？</p>
</blockquote>
<h3 id="6-生产者和消费者问题"><a href="#6-生产者和消费者问题" class="headerlink" title="6.生产者和消费者问题"></a>6.生产者和消费者问题</h3><p>面试：单例模式、排序算法、生产者和消费者、死锁</p>
<h4 id="synchronized版本"><a href="#synchronized版本" class="headerlink" title="synchronized版本"></a>synchronized版本</h4><blockquote>
<p>wait()/notifyAll()</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">//线程间通信问题：生产者和消费者问题,等待唤醒，通知唤醒</span><br><span class="line">//线程交替执行</span><br><span class="line">public class A &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data = new Data();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i=0;i&lt;10;i++)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i=0;i&lt;10;i++)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等待、业务、通知</span><br><span class="line">class Data &#123; //资源</span><br><span class="line">    private int num = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        if (num != 0) &#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();//wait()方法会释放锁</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        //通知其他线程，+1完毕了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        if (num == 0) &#123;</span><br><span class="line">            //等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        //通知其他线程，-1完毕了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>四个线程的synchronized</p>
</blockquote>
<p>出现问题。</p>
<p><strong>虚假唤醒:</strong></p>
<blockquote>
<p>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功</p>
<p> 1.比如说买货，如果商品本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了 ，但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁</p>
</blockquote>
<p><strong>被唤醒之后，它是从上次被挂起的地方，继续往下执行</strong></p>
<blockquote>
<p>因为if只会执行一次，执行完会接着向下执行if（）外边的 而while不会，直到条件满足才会向下执行while（）外边的</p>
</blockquote>
<p>拿两个加法线程A、B来说，A执行一次后，A再执行，执行时调用了wait方法，那它会等待，此时会释放锁，之后线程B获得锁并且也会执行wait方法，两个加线程一起等待被唤醒。此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，那么这俩加线程不会一起执行，其中A获取了锁并且加1，执行完毕之后B再执行。如果是if的话，那么A修改完num后，B不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，B还会去判断num的值，因此就不会执行。</p>
<p><strong>防止虚假唤醒。if改为while判断。</strong></p>
<h4 id="lock版本"><a href="#lock版本" class="headerlink" title="lock版本"></a>lock版本</h4><blockquote>
<p>await()/signal()</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">public class B &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data2 data = new Data2();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;D&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等待、业务、通知</span><br><span class="line">class Data2 &#123; //资源</span><br><span class="line">    private int num = 0;</span><br><span class="line"></span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void increment() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num != 0) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;加阻塞&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            //通知其他线程，+1完毕了</span><br><span class="line">            condition.signalAll();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    public void decrement() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (num == 0) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;减阻塞&quot;);</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            //通知其他线程，-1完毕了</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任何一个新技术，绝对不仅仅只是覆盖原技术，应该有优势和补充。</p>
<blockquote>
<p>Condition，精准的通知和唤醒线程</p>
</blockquote>
<p><strong>随机状态，需要有序执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">//线程A执行完通知线程B，线程B执行完通知C，线程C执行完通知A</span><br><span class="line">public class C &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data3 data = new Data3();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Data3 &#123; //资源</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line">    Condition condition1 = lock.newCondition();</span><br><span class="line">    Condition condition2 = lock.newCondition();</span><br><span class="line">    Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void printA() &#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //业务，判断，执行，通知</span><br><span class="line">            while (num != 1) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;AAA&quot;);</span><br><span class="line">            //唤醒指定</span><br><span class="line">            num = 2;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printB() &#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //业务，判断，执行，通知</span><br><span class="line">            while (num != 2) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;BBB&quot;);</span><br><span class="line">            //唤醒指定</span><br><span class="line">            num = 3;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printC() &#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //业务，判断，执行，通知</span><br><span class="line">            while (num != 3) &#123;</span><br><span class="line">                //等待</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;=&gt;CCC&quot;);</span><br><span class="line">            //唤醒指定</span><br><span class="line">            num = 1;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-八锁现象"><a href="#7-八锁现象" class="headerlink" title="7.八锁现象"></a>7.八锁现象</h3><blockquote>
<p>深刻理解锁：8锁：关于锁的八个问题</p>
</blockquote>
<p>//8锁，关于锁的八个问题</p>
<ul>
<li><strong>问题1：</strong>一个对象，标准情况下，两个线程打印是先发短信还是先打电话？   synchronized 锁的对象是方法的调用者，两个方法用的是一个锁，谁先拿到谁先执行</li>
<li><strong>问题2：</strong>一个对象，sendMsg()延迟四秒，两个线程打印是先发短信还是先打电话？   synchronized 锁的对象是方法的调用者， 两个方法用的是一个锁，谁先拿到谁先执行</li>
<li><strong>问题3：</strong>一个对象，增加了个普通方法hello(),两个线程打印是先发短信还是先hello？  普通方法没有锁,不是同步方法，不受锁的影响</li>
<li><strong>问题4：</strong>两个对象，分别调用sendMsg()和call(),两个线程打印是先发短信还是先打电话？ 两把锁，按时间执行</li>
<li><strong>问题5：</strong>一个对象，sendMsg()和call()是静态的同步方法,两个线程打印是先发短信还是先打电话？static类一加载就有了，锁的是class,用的也是同一个锁</li>
<li><strong>问题6：</strong>两个对象，分别调用sendMsg()和call()，是静态的同步方法,两个线程打印是先发短信还是先打电话？static类一加载就有了，锁的是class,用的也是同一个锁</li>
<li><strong>问题7：</strong>一个对象，sendMsg()是静态同步方法，call()是非静态的同步方法，两个线程打印是先发短信还是先打电话？两把锁，按时间执行</li>
<li><strong>问题8：</strong>两个对象,分别调用sendMsg()是静态同步方法，call()是非静态的同步方法，两个线程打印是先发短信还是先打电话？两把锁，按时间执行</li>
</ul>
<p>1.Test1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.xmx.锁;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">//8锁，关于锁的八个问题</span><br><span class="line">//问题1：标准情况下，两个线程打印是先发短信还是先打电话？</span><br><span class="line">//问题2：sendMsg()延迟四秒，两个线程打印是先发短信还是先打电话？</span><br><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone = new Phone();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendMsg();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone &#123;</span><br><span class="line">    //synchronized 锁的对象是方法的调用者</span><br><span class="line">    //两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">    public synchronized void sendMsg() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.Test2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.xmx.锁;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">//8锁，关于锁的八个问题</span><br><span class="line">//问题1：标准情况下，两个线程打印是先发短信还是先打电话？   两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">//问题2：sendMsg()延迟四秒，两个线程打印是先发短信还是先打电话？    两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">//问题3：增加了个普通方法hello(),两个线程打印是先发短信还是先hello？  普通方法没有锁,不是同步方法，不受锁的影响</span><br><span class="line">//问题4：两个对象，分别调用sendMsg()和call(),两个线程打印是先发短信还是先打电话？ 两把锁，按时间执行</span><br><span class="line">public class Test2 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone2 phone = new Phone2();</span><br><span class="line">        Phone2 phone2 = new Phone2();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendMsg();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2 &#123;</span><br><span class="line">    //synchronized 锁的对象是方法的调用者</span><br><span class="line">    //两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">    public synchronized void sendMsg() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //没有锁,不是同步方法，不受锁的影响</span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.Test3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.xmx.锁;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">//8锁，关于锁的八个问题</span><br><span class="line">//问题1：一个对象，标准情况下，两个线程打印是先发短信还是先打电话？   synchronized 锁的对象是方法的调用者，两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">//问题2：一个对象，sendMsg()延迟四秒，两个线程打印是先发短信还是先打电话？   synchronized 锁的对象是方法的调用者， 两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">//问题3：一个对象，增加了个普通方法hello(),两个线程打印是先发短信还是先hello？  普通方法没有锁,不是同步方法，不受锁的影响</span><br><span class="line">//问题4：两个对象，分别调用sendMsg()和call(),两个线程打印是先发短信还是先打电话？ 两把锁，按时间执行</span><br><span class="line">//问题5：一个对象，sendMsg()和call()是静态的同步方法,两个线程打印是先发短信还是先打电话？static类一加载就有了，锁的是class,用的也是同一个锁</span><br><span class="line">//问题6：两个对象，分别调用sendMsg()和call()，是静态的同步方法,两个线程打印是先发短信还是先打电话？static类一加载就有了，锁的是class,用的也是同一个锁</span><br><span class="line">public class Test3 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone3 phone = new Phone3();</span><br><span class="line">        Phone3 phone2 = new Phone3();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendMsg();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone3 &#123;</span><br><span class="line">    //synchronized 锁的对象是方法的调用者</span><br><span class="line">    //两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">    public static synchronized void sendMsg() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void call() &#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //没有锁,不是同步方法，不受锁的影响</span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Test4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.xmx.锁;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">//8锁，关于锁的八个问题</span><br><span class="line">//问题1：一个对象，标准情况下，两个线程打印是先发短信还是先打电话？   synchronized 锁的对象是方法的调用者，两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">//问题2：一个对象，sendMsg()延迟四秒，两个线程打印是先发短信还是先打电话？   synchronized 锁的对象是方法的调用者， 两个方法用的是一个锁，谁先拿到谁先执行</span><br><span class="line">//问题3：一个对象，增加了个普通方法hello(),两个线程打印是先发短信还是先hello？  普通方法没有锁,不是同步方法，不受锁的影响</span><br><span class="line">//问题4：两个对象，分别调用sendMsg()和call(),两个线程打印是先发短信还是先打电话？ 两把锁，按时间执行</span><br><span class="line">//问题5：一个对象，sendMsg()和call()是静态的同步方法,两个线程打印是先发短信还是先打电话？static类一加载就有了，锁的是class,用的也是同一个锁</span><br><span class="line">//问题6：两个对象，分别调用sendMsg()和call()，是静态的同步方法,两个线程打印是先发短信还是先打电话？static类一加载就有了，锁的是class,用的也是同一个锁</span><br><span class="line">//问题7：一个对象，sendMsg()是静态同步方法，call()是非静态的同步方法，两个线程打印是先发短信还是先打电话？两把锁，按时间执行</span><br><span class="line">//问题8：两个对象,分别调用sendMsg()是静态同步方法，call()是非静态的同步方法，两个线程打印是先发短信还是先打电话？两把锁，按时间执行</span><br><span class="line">public class Test4 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone4 phone = new Phone4();</span><br><span class="line">        Phone4 phone2 = new Phone4();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendMsg();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone4 &#123;</span><br><span class="line">    //锁的是class类模板</span><br><span class="line">    public static synchronized void sendMsg() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;发短信&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //锁的调用者</span><br><span class="line">    public  synchronized void call() &#123;</span><br><span class="line">        System.out.println(&quot;打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //没有锁,不是同步方法，不受锁的影响</span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<p>new this 具体的一个对象</p>
<p>static 唯一的一个class模板</p>
<h3 id="8-集合类不安全"><a href="#8-集合类不安全" class="headerlink" title="8.集合类不安全"></a>8.集合类不安全</h3><h4 id="List不安全"><a href="#List不安全" class="headerlink" title="List不安全"></a>List不安全</h4><blockquote>
<p>List不安全,并发运行出现ConcurrentModificationException并发修改异常问题</p>
</blockquote>
<p>怎么解决？</p>
<p>1.Vector</p>
<p>2.工具类Collections有synchronizedList转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ListTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = Collections. (new ArrayList&lt;&gt;());</span><br><span class="line">        for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.CopyOnwriteArrayList 写入时复制，COW，计算机程序设计领域的一种优化策略。</p>
<p>多线程在调用的时候，读取是固定的，写入为了避免覆盖，造成数据异常，就会复制一份。</p>
<p><strong>CopyOnwriteArrayList 比    Vector 更好，只要有synchronized，效率就会比较低。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ListTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Set不安全"><a href="#Set不安全" class="headerlink" title="Set不安全"></a>Set不安全</h4><blockquote>
<p>ConcurrentModificationException 同理</p>
</blockquote>
<p>解决方式：</p>
<p>1.工具类Collections有synchronizedSet转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">        for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.CopyOnWriteArraySet</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashSet底层-gt-HashMap"><a href="#HashSet底层-gt-HashMap" class="headerlink" title="HashSet底层=&gt;HashMap"></a>HashSet底层=&gt;HashMap</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">       map = new HashMap&lt;&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">//本质是HashMap的Key，无法重复的,PRESENT不变的值</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map不安全"><a href="#Map不安全" class="headerlink" title="Map不安全"></a>Map不安全</h4><blockquote>
<p>ConcurrentModificationException</p>
</blockquote>
<p>HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();默认等价HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(16,0.75f);工作中不这样用HashMap，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initialCapacity加载因子,loadFactor初始化容量</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>

<p>解决方式：</p>
<p>1.工具类Collections有synchronizedMap转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, String&gt; map =Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread()</span><br><span class="line">                        .getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>2.ConcurrentHashMap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread()</span><br><span class="line">                        .getName(), UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-Callable类-简单"><a href="#9-Callable类-简单" class="headerlink" title="9.Callable类(简单)"></a>9.Callable类(简单)</h3><p>1.可以有返回值</p>
<p>2.可以抛出异常</p>
<p>3.方法不同,run()/call()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CallableTest &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //FutureTask是Runnable的实现类</span><br><span class="line">        MyThread thread=new MyThread();</span><br><span class="line">        FutureTask futureTask=new FutureTask(thread);</span><br><span class="line">        new Thread(futureTask,&quot;A&quot;).start();</span><br><span class="line">        System.out.println(futureTask.get());//获取返回结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String  call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;call()&quot;);</span><br><span class="line">        return &quot;123&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>futureTask.get()获取返回结果，这个get方法可能会产生阻塞，一般会把他放到最后，或者异步通信</p>
</li>
<li><p>再运行有缓存，两个线程只走一个</p>
</li>
</ul>
<h3 id="10-常用辅助类"><a href="#10-常用辅助类" class="headerlink" title="10.常用辅助类"></a>10.常用辅助类</h3><h4 id="1-CountDownLatch减法计数器"><a href="#1-CountDownLatch减法计数器" class="headerlink" title="1.CountDownLatch减法计数器"></a>1.CountDownLatch减法计数器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//计数器(减法)</span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch countDownLatch=new CountDownLatch(6);//总数</span><br><span class="line"></span><br><span class="line">        for (int i=1;i&lt;=6;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;\t出去&quot;);</span><br><span class="line">                countDownLatch.countDown();//-1</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();//等待计数器归零，再向下执行</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;关门&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当计数为0，就会唤醒countDownLatch.await()，执行下面的代码</p>
<h4 id="2-CyclicBarrier加法计数器"><a href="#2-CyclicBarrier加法计数器" class="headerlink" title="2.CyclicBarrier加法计数器"></a>2.CyclicBarrier加法计数器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//加法计数器</span><br><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //集齐七颗龙珠召唤神龙</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;召唤神龙成功&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (int i=1;i&lt;=7;i++)&#123;</span><br><span class="line">            //lambda表达式拿不到i,新建final变量就行(系统会自带加final关键字)</span><br><span class="line">            final int temp=i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;\t收集了&quot;+ temp +&quot;颗龙珠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Semaphore信号量"><a href="#3-Semaphore信号量" class="headerlink" title="3.Semaphore信号量"></a>3.Semaphore信号量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore=new Semaphore(3);//线程数量（停车位）/限流</span><br><span class="line">        for (int i=1;i&lt;=6;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //得到acquire</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;抢到车位&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;离开车位&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    //释放 release</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    semaphore.acquire();获得，假如满了会等待，直到释放为止。</p>
<p>semaphore.release();释放，将当前的信号量释放+1，然后唤醒等待线程。</p>
<p>作用：多共享资源互斥，限流，控制最大线程数</p>
<h3 id="11-读写锁（独占锁、共享锁）"><a href="#11-读写锁（独占锁、共享锁）" class="headerlink" title="11.读写锁（独占锁、共享锁）"></a>11.读写锁（独占锁、共享锁）</h3><blockquote>
<p>ReadWriteLock</p>
</blockquote>
<ul>
<li>读可以被多线程同时读，写只能一个线程写</li>
</ul>
<p>读-读：可以共存</p>
<p>读-写：不能共存</p>
<p>写-写：不能共存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyCache cache = new MyCache();</span><br><span class="line">        MyCacheLock myCacheLock=new MyCacheLock();</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            final int temp = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">//                cache.put(temp + &quot;&quot;, temp + &quot;&quot;);</span><br><span class="line">                myCacheLock.put(temp + &quot;&quot;, temp + &quot;&quot;);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            final int temp = i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">//                cache.get(temp + &quot;&quot;);</span><br><span class="line">                myCacheLock.get(temp + &quot;&quot;);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自定义缓存</span><br><span class="line">class MyCache &#123;</span><br><span class="line">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //写</span><br><span class="line">    public void put(String key, Object value) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;写入OK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读</span><br><span class="line">    public void get(String key) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);</span><br><span class="line">        Object o = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;读取完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自定义缓存:加锁</span><br><span class="line">class MyCacheLock &#123;</span><br><span class="line">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    //读写锁，更加细粒度控制</span><br><span class="line">    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    //写,只有一个线程写</span><br><span class="line">    public void put(String key, Object value) &#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;写入OK&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //读，多个线程同时读</span><br><span class="line">    public void get(String key) &#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;读取完成&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-阻塞队列BlockingQueue"><a href="#12-阻塞队列BlockingQueue" class="headerlink" title="12.阻塞队列BlockingQueue"></a>12.阻塞队列BlockingQueue</h3><p>不得不阻塞：写入：队列满了。读取：队列空的。</p>
<blockquote>
<p>BlockingQueue接口(父类是Collection),Queue和List及Set同级,是Queue的子接口</p>
</blockquote>
<p>使用场景：多线程并发处理，线程池</p>
<p>四组API</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer</td>
<td>put</td>
<td>offer(xxx,2, TimeUnit.SECONDS)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>poll</td>
<td>take</td>
<td>poll(xxx,TimeUnit.SECONDS)</td>
</tr>
<tr>
<td>判断队首元素</td>
<td>element</td>
<td>peek</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>1.抛出异常</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void test1()&#123;</span><br><span class="line">ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(arrayBlockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(arrayBlockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(arrayBlockingQueue.add(&quot;c&quot;));</span><br><span class="line">//      System.out.println(arrayBlockingQueue.add(&quot;d&quot;));</span><br><span class="line">System.out.println(&quot;============&quot;);</span><br><span class="line">System.out.println(arrayBlockingQueue.remove());</span><br><span class="line">System.out.println(arrayBlockingQueue.remove());</span><br><span class="line">System.out.println(arrayBlockingQueue.remove());</span><br><span class="line">//System.out.println(arrayBlockingQueue.remove());&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arrayBlockingQueue.element());//查看队首元素</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队列满了出现Queue full异常</p>
</blockquote>
<blockquote>
<p>队列为空出现NoSuchElementException异常</p>
</blockquote>
<p><strong>2.有返回值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void test2()&#123;</span><br><span class="line">        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">        System.out.println(arrayBlockingQueue.offer(&quot;a&quot;));</span><br><span class="line">        System.out.println(arrayBlockingQueue.offer(&quot;b&quot;));</span><br><span class="line">        System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));</span><br><span class="line">//        System.out.println(arrayBlockingQueue.offer(&quot;d&quot;)); //返回false</span><br><span class="line">        System.out.println(&quot;============&quot;);</span><br><span class="line">        System.out.println(arrayBlockingQueue.poll());</span><br><span class="line">        System.out.println(arrayBlockingQueue.poll());</span><br><span class="line">        System.out.println(arrayBlockingQueue.poll());</span><br><span class="line">//        System.out.println(arrayBlockingQueue.poll()); //返回null</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arrayBlockingQueue.peek());//查看队首元素</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队列满了返回false</p>
</blockquote>
<blockquote>
<p>队列为空返回null</p>
</blockquote>
<p><strong>3.阻塞等待</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//等待，阻塞（一直等待）</span><br><span class="line">public static void test3() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">    arrayBlockingQueue.put(&quot;a&quot;);</span><br><span class="line">    arrayBlockingQueue.put(&quot;b&quot;);</span><br><span class="line">    arrayBlockingQueue.put(&quot;c&quot;);</span><br><span class="line">    arrayBlockingQueue.put(&quot;d&quot;);//队列没位置了，一直等待</span><br><span class="line"></span><br><span class="line">    arrayBlockingQueue.take();</span><br><span class="line">    arrayBlockingQueue.take();</span><br><span class="line">    arrayBlockingQueue.take();</span><br><span class="line">    arrayBlockingQueue.take();//没有元素，一直等待</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.超时等待</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//等待，阻塞（等待超时）</span><br><span class="line">public static void test4() throws InterruptedException &#123;</span><br><span class="line">    ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">    System.out.println(arrayBlockingQueue.offer(&quot;a&quot;));</span><br><span class="line">    System.out.println(arrayBlockingQueue.offer(&quot;b&quot;));</span><br><span class="line">    System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));</span><br><span class="line">    System.out.println(arrayBlockingQueue.offer(&quot;d&quot;,2, TimeUnit.SECONDS));//超过两秒就退出</span><br><span class="line">    System.out.println(arrayBlockingQueue.peek());</span><br><span class="line">    System.out.println(&quot;============&quot;);</span><br><span class="line">    System.out.println(arrayBlockingQueue.poll());</span><br><span class="line">    System.out.println(arrayBlockingQueue.poll());</span><br><span class="line">    System.out.println(arrayBlockingQueue.poll());</span><br><span class="line">    System.out.println(arrayBlockingQueue.poll(2,TimeUnit.SECONDS));//超过两秒就退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="同步队列SynchronousQueue"><a href="#同步队列SynchronousQueue" class="headerlink" title="同步队列SynchronousQueue"></a>同步队列SynchronousQueue</h4><p>没有容量，不存储元素，进去一个元素必须取出才能放另一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronousQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue =  new SynchronousQueue&lt;&gt;();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;put 1&quot;);</span><br><span class="line">                blockingQueue.put(&quot;1&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;put 2&quot;);</span><br><span class="line">                blockingQueue.put(&quot;2&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;put 3&quot;);</span><br><span class="line">                blockingQueue.put(&quot;3&quot;);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;T1&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;==&gt;&quot;+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;==&gt;&quot;+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;==&gt;&quot;+blockingQueue.take());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;T2&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-线程池-重点"><a href="#13-线程池-重点" class="headerlink" title="13.线程池(重点)"></a>13.线程池(重点)</h3><p><strong>3大方法、7大参数、4种拒绝策略</strong></p>
<blockquote>
<p>池化技术</p>
<p>事先准备好一些资源，需要使用就拿，用完归还。</p>
</blockquote>
<p>程序的运行，本质：占用系统的资源</p>
<p>优化资源的使用=》池化技术</p>
<p>线程池、连接池、内存池、对象池。。。</p>
<p>创建和销毁浪费资源。</p>
<p><strong>线程池的好处：</strong></p>
<p>1.降低资源的消耗</p>
<p>2.提高响应的速度</p>
<p>3.方便管理</p>
<p><strong>线程可以复用、可以控制最大并发数、管理线程</strong></p>
<blockquote>
<p>线程池：三大方法</p>
</blockquote>
<h4 id="三大方法"><a href="#三大方法" class="headerlink" title="三大方法"></a>三大方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadExecutor();</span><br><span class="line">//单个线程的线程池</span><br><span class="line">Executors.newFixedThreadPool(5);//固定的线程池</span><br><span class="line">Executors.newCachedThreadPool();//可伸缩的线程池</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">return new ThreadPoolExecutor(nThreads, nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">return new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>均调用ThreadPoolExecutor</p>
<h4 id="七个参数"><a href="#七个参数" class="headerlink" title="七个参数"></a>七个参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(</span><br><span class="line"></span><br><span class="line">int corePoolSize,//核心线程大小</span><br><span class="line"></span><br><span class="line">int maximumPoolSize,//最大的线程池大小</span><br><span class="line"></span><br><span class="line">long keepAliveTime,//超时了，不调用就释放</span><br><span class="line"></span><br><span class="line">TimeUnit unit,//超时单位</span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span><br><span class="line"></span><br><span class="line">ThreadFactory threadFactory,//创建线程工厂</span><br><span class="line"></span><br><span class="line">RejectedExecutionHandler handler//拒绝策略</span><br><span class="line"></span><br><span class="line">) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.acc = System.getSecurityManager() == null ?</span><br><span class="line">            null :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h4><p><strong>1.new ThreadPoolExecutor.AbortPolicy()</strong></p>
<p>线程池和阻塞队列都满了，丢掉任务，抛出异常</p>
<p><strong>2.new ThreadPoolExecutor.CallerRunsPolicy()</strong></p>
<p>线程池和阻塞队列都满了，哪来的回哪去（由调用线程处理该任务）</p>
<p><strong>3.new ThreadPoolExecutor.DiscardPolicy()</strong></p>
<p>线程池和阻塞队列都满了，丢掉任务，不会抛出异常</p>
<p><strong>4.new ThreadPoolExecutor.DiscardOldestPolicy()</strong></p>
<p>线程池和阻塞队列都满了，丢弃队列最前面的任务，然后重新提交被拒绝的任务</p>
<blockquote>
<p>手动创建线程池</p>
</blockquote>
<p>最大承载：max+queue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">超出最大承载</span><br><span class="line">RejectedExecutionException//拒绝策略异常</span><br></pre></td></tr></table></figure>



<p><img src="D:\笔记\JAVA学习\线程池.png" alt="线程池"></p>
<h4 id="最大线程到底该如何定义"><a href="#最大线程到底该如何定义" class="headerlink" title="最大线程到底该如何定义"></a>最大线程到底该如何定义</h4><blockquote>
<p>最大线程到底该如何定义</p>
</blockquote>
<p>1.CPU密集型</p>
<p>几核CPU就定义几，这样可以保持CPU效率最高。</p>
<p>获取CPU核数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure>

<p>2.IO密集型</p>
<p>判断程序中最耗IO的线程数，设置为它的两倍。</p>
<h3 id="14-四大函数式接口（重点、简单）"><a href="#14-四大函数式接口（重点、简单）" class="headerlink" title="14.四大函数式接口（重点、简单）"></a>14.四大函数式接口（重点、简单）</h3><blockquote>
<p>程序员必须掌握的</p>
</blockquote>
<h3 id="1-lambda表达式"><a href="#1-lambda表达式" class="headerlink" title="1.lambda表达式"></a>1.lambda表达式</h3><p>2.链式编程</p>
<p>3.函数式接口</p>
<p>4.Stream流式计算</p>
<blockquote>
<p>函数式接口</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br><span class="line">超多使用，简化编程模型，在新版本框架中大量应用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数式接口都可以用lambda简写</p>
</blockquote>
<h4 id="1-Function函数型接口"><a href="#1-Function函数型接口" class="headerlink" title="1.Function函数型接口"></a>1.Function函数型接口</h4><p>有一个输入参数，有一个输出参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//工具类，输出输入的值</span><br><span class="line">// Function function=new Function&lt;String,String&gt;()&#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public String apply(String str) &#123;</span><br><span class="line">//                return str;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line">Function&lt;String,String&gt; function=(str)-&gt;&#123;return str;&#125;;</span><br><span class="line">System.out.println(function.apply(&quot;abc&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Predicate断定型接口"><a href="#2-Predicate断定型接口" class="headerlink" title="2.Predicate断定型接口"></a>2.Predicate断定型接口</h4><p>有一个输入参数，返回值只能是布尔值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        //判断字符串是否为空</span><br><span class="line">//        Predicate predicate=new Predicate&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public boolean test(String str) &#123;</span><br><span class="line">//                return str.isEmpty();</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line">        Predicate&lt;String&gt; predicate=(str)-&gt;&#123;return str.isEmpty();&#125;;</span><br><span class="line">        System.out.println(predicate.test(&quot;&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Consumer消费型接口"><a href="#3-Consumer消费型接口" class="headerlink" title="3.Consumer消费型接口"></a>3.Consumer消费型接口</h4><p>只有输入，没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //打印字符串</span><br><span class="line">        </span><br><span class="line">//        Consumer consumer=new Consumer&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public void accept(String str) &#123;</span><br><span class="line">//                System.out.println(str);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line">        Consumer&lt;String&gt; consumer=(str)-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(&quot;aaa&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Supplier供给型接口"><a href="#4-Supplier供给型接口" class="headerlink" title="4.Supplier供给型接口"></a>4.Supplier供给型接口</h4><p>没有参数，只有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        Supplier supplier=new Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public Integer get() &#123;</span><br><span class="line">//                return 1024;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line">        Supplier supplier=()-&gt;&#123;return 1024;&#125;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-Stream流式计算"><a href="#15-Stream流式计算" class="headerlink" title="15.Stream流式计算"></a>15.Stream流式计算</h3><blockquote>
<p>什么是Stream流式计算</p>
</blockquote>
<p>大数据=存储+计算</p>
<p>集合、MYSQL本质就是存储东西。</p>
<p>计算都交给流来计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    User u1=new User(1,&quot;a&quot;,21);</span><br><span class="line">    User u2=new User(2,&quot;b&quot;,22);</span><br><span class="line">    User u3=new User(3,&quot;c&quot;,23);</span><br><span class="line">    User u4=new User(4,&quot;d&quot;,24);</span><br><span class="line">    User u5=new User(5,&quot;e&quot;,25);</span><br><span class="line">    User u6=new User(6,&quot;F&quot;,26);</span><br><span class="line">    //集合是存储</span><br><span class="line">    List&lt;User&gt; list= Arrays.asList(u1,u2,u3,u4,u5,u6);</span><br><span class="line">    //计算交给stream</span><br><span class="line">    //ID是偶数</span><br><span class="line">    //年龄大于23</span><br><span class="line">    //把用户名字都转为大写</span><br><span class="line">    //用户名倒置排序</span><br><span class="line">    //只输出一个用户</span><br><span class="line">    </span><br><span class="line">    //链式编程</span><br><span class="line">    list.stream().filter((u)-&gt;&#123;return u.getUid()%2==0;&#125;)</span><br><span class="line">            .filter((u)-&gt;&#123;return u.getAge()&gt;23;&#125;)</span><br><span class="line">            .map((u)-&gt;&#123;return u.getUname().toUpperCase();&#125;)</span><br><span class="line">            .sorted((uu1,uu2)-&gt;&#123;return uu2.compareTo(uu1);&#125;)</span><br><span class="line">            .limit(1)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-ForkJoin"><a href="#16-ForkJoin" class="headerlink" title="16.ForkJoin"></a>16.ForkJoin</h3><blockquote>
<p>什么是ForkJoin</p>
</blockquote>
<p>JDK1.7，并行执行任务，大数据量才能提高效率。</p>
<p>把大任务分成小任务，<strong>特点：工作窃取</strong></p>
<p>双端队列</p>
<blockquote>
<p>使用ForkJoin</p>
</blockquote>
<p>1.ForkJoinPool执行</p>
<p>2.计算任务forkjoinpool.execute(ForkJoinTask task)</p>
<p>3.计算类继承RecursiveTask</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//求和计算的任务(ForkJoin/Stream并行流)</span><br><span class="line">public class Test1 extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class="line">    private Long start;//1</span><br><span class="line">    private Long end;//10 0000 0000</span><br><span class="line">    private Long temp=10000L;</span><br><span class="line"></span><br><span class="line">    public Test1(Long start, Long end) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算方法</span><br><span class="line">    @Override</span><br><span class="line">    protected Long compute() &#123;</span><br><span class="line">        if(end-start&gt;temp)&#123;</span><br><span class="line">            //分支合并计算</span><br><span class="line">            long middle= (start + end) / 2;</span><br><span class="line">            Test1 test1 = new Test1(start, middle);</span><br><span class="line">            test1.fork();//拆分任务，把任务压入线程队列</span><br><span class="line">            Test1 test2 = new Test1(middle+1, end);</span><br><span class="line">            test2.fork();</span><br><span class="line">            return test1.join()+test2.join();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Long sum = 0L;</span><br><span class="line">            for (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    //普通程序员</span><br><span class="line">    //sum=500000000500000000	时间：10899</span><br><span class="line">    @Test</span><br><span class="line">    public void a()&#123;</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        Long sum = 0L;</span><br><span class="line">        for (Long i = 1L; i &lt;= 10_0000_0000; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        long end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;sum=&quot;+sum+&quot;\t时间：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    //ForkJoin会使用</span><br><span class="line">    //sum=500000000500000000时间：5132</span><br><span class="line">    @Test</span><br><span class="line">    public void b() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool forkJoinPool=new ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task=new Test1(0L,10_0000_0000L);</span><br><span class="line">//        forkJoinPool.execute(task);//执行任务</span><br><span class="line">        Long sum=forkJoinPool.submit(task).get();//提交任务</span><br><span class="line">        long end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;sum=&quot;+sum+&quot;时间：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Steam并行流</span><br><span class="line">    //sum=500000000500000000时间：1274</span><br><span class="line">    @Test</span><br><span class="line">    public void c()&#123;</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum);</span><br><span class="line">        long end=System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;sum=&quot;+sum+&quot;时间：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-异步回调"><a href="#17-异步回调" class="headerlink" title="17.异步回调"></a>17.异步回调</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        //没有返回值的runAsync异步回调</span><br><span class="line">//        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">//            try &#123;</span><br><span class="line">//                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">//            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">//            System.out.println(Thread.currentThread().getName()+&quot;runAsync=&gt;Void&quot;);</span><br><span class="line">//        &#125;);</span><br><span class="line">//        System.out.println(&quot;11111&quot;);</span><br><span class="line">//        completableFuture.get();//阻塞获取执行结果</span><br><span class="line"></span><br><span class="line">        //有返回值得supplyAsync异步回调</span><br><span class="line">        //返回错误信息</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;runAsync=&gt;Integer&quot;);</span><br><span class="line">            int i = 10 / 0;</span><br><span class="line">            return 1024;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            //正常得返回结果</span><br><span class="line">            System.out.println(&quot;t=&gt;&quot; + t);</span><br><span class="line">            System.out.println(&quot;u=&gt;&quot; + u);//错误信息</span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());//获取到错误得返回结果</span><br><span class="line">            return 233;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-JMM"><a href="#18-JMM" class="headerlink" title="18.JMM"></a>18.JMM</h3><blockquote>
<p>volatile是什么？</p>
</blockquote>
<p>volatile是java虚拟机提供轻量级得同步机制。</p>
<p>1.保证可见性</p>
<p>2.不保证原子性</p>
<p>3.禁止指令重排</p>
<blockquote>
<p>JMM</p>
</blockquote>
<p>JMM:java内存模型，不存在得东西，概念、约定</p>
<p><strong>关于JMM得一些同步约定：</strong></p>
<p>1.线程解锁前、必须把共享变量立刻刷回主存。</p>
<p>2.线程加锁前，必须读取主存中得最新值到工作内存中。</p>
<p>3.加锁和解锁是同一把锁。</p>
<blockquote>
<p>JMM中8种操作</p>
</blockquote>
<p>1.read （读取）、2.load（载入）</p>
<p>3.use（使用）、 4.assign(赋值)</p>
<p>5.store(存储)、6.write（写入）</p>
<p>7.lock（锁定）、8.unlock（解锁）</p>
<p><strong>线程A和线程B都读取了主存的值，但线程B修改值并写入主存，线程A还在使用原来的值，和主存的值不一致，相对于线程A，则没有可见性。</strong></p>
<p><strong>需要线程A指定主内存中的值发生了变化了。</strong></p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h5><blockquote>
<p>保证可见性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private volatile static int num=0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        while (num==0)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num=1;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h5><blockquote>
<p>不保证原子性</p>
</blockquote>
<p>原子性：不可分割</p>
<p>线程在执行任务的时候，不能被分割，要么同时成功，要么同时失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//不保证原子性</span><br><span class="line">private volatile static int num=0;</span><br><span class="line">public  static void add()&#123;//synchronized可以保证原子性</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for (int i=1;i&lt;=20;i++)&#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int j=0;j&lt;1000;j++)&#123;</span><br><span class="line">                add();//理论上nun为2万</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    while (Thread.activeCount()&gt;2)&#123;//main、GC线程默认执行</span><br><span class="line">        Thread.yield();//礼让,main线程主动礼让线程给其他线程执行</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+&quot; &quot;+num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有synchronized或者lock，怎么保证原子性？</p>
<p><strong>使用原子类，解决原子性问题</strong></p>
<blockquote>
<p>原子类为什么这么高级？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private volatile static AtomicInteger num=new AtomicInteger();</span><br><span class="line">public  static void add()&#123;</span><br><span class="line">//synchronized可以保证原子性</span><br><span class="line">num.getAndIncrement();//CAS，在内存中修改值，加1操作</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        for (int i=1;i&lt;=20;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for (int j=0;j&lt;1000;j++)&#123;</span><br><span class="line">                    add();//理论上nun为2万</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">while (Thread.activeCount()&gt;2)&#123;//main、GC线程默认执行</span><br><span class="line">Thread.yield();//礼让,main线程主动礼让线程给其他线程执行</span><br><span class="line">&#125;     System.out.println(Thread.currentThread().getName()+&quot; &quot;+num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些类的底层直接和操作系统挂钩。</p>
<h5 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h5><blockquote>
<p>禁止指令重排</p>
</blockquote>
<p>什么是指令重排？你写的程序，计算机并不是按照你写的那样去执行的。</p>
<p><strong>处理器在进行指令重排的时候，会考虑数据之间的依赖性。</strong></p>
<p>源代码-&gt;编译器优化重排-&gt;指令并行也可能重排-&gt;内存系统也会重排-&gt;执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x=1;  //1</span><br><span class="line">int y=2;  //2</span><br><span class="line">x=x+5;  //3</span><br><span class="line">y=x+x;  //4</span><br><span class="line">我们期望的1234,但是可能执行的时候变成2134,1324，不可能是 4123</span><br></pre></td></tr></table></figure>

<p>可能造成影响的结果</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x=a</td>
<td>y=b</td>
</tr>
<tr>
<td>b=1</td>
<td>a=2</td>
</tr>
</tbody></table>
<p>正常结果：x=0,y=0，可能无依赖关系指令重排：</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>b=1</td>
<td>a=2</td>
</tr>
<tr>
<td>x=a</td>
<td>y=b</td>
</tr>
</tbody></table>
<p>指令重排导致的结果：x=2,y=1</p>
<blockquote>
<p>非计算机专业</p>
</blockquote>
<p>volatile可以避免指令重排</p>
<p>内存屏障、CPU指令、作用：</p>
<p>1.保证特定的操作的执行顺序</p>
<p>2.保证某些变量的内存可见性（利用这些特性，volatile实现了可见性）</p>
<h3 id="19-彻底玩转单例模式"><a href="#19-彻底玩转单例模式" class="headerlink" title="19.彻底玩转单例模式"></a>19.彻底玩转单例模式</h3><p>1.构造函数私有</p>
<p>2.私有自身对象成员变量</p>
<p>3.公有获取对象方法</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><blockquote>
<p>饿汉式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private Hungry()&#123;&#125;</span><br><span class="line">//可能会浪费空间</span><br><span class="line">private byte[] data=new byte[1024*1024];</span><br><span class="line"></span><br><span class="line">private final static Hungry Hungry=new Hungry();</span><br><span class="line">public static Hungry getInstance()&#123;</span><br><span class="line">    return Hungry;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><blockquote>
<p>懒汉式</p>
</blockquote>
<h5 id="普通单线程，懒汉式"><a href="#普通单线程，懒汉式" class="headerlink" title="普通单线程，懒汉式"></a>普通单线程，懒汉式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//单线程是ok的</span><br><span class="line">private LazyMan()&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    public static LazyMan getInstance()&#123;</span><br><span class="line">        if(lazyMan==null)&#123;</span><br><span class="line">            lazyMan=new LazyMan();</span><br><span class="line">        &#125;</span><br><span class="line">        return lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="DCL懒汉式-双重检测模式的懒汉单例"><a href="#DCL懒汉式-双重检测模式的懒汉单例" class="headerlink" title="DCL懒汉式 :双重检测模式的懒汉单例"></a>DCL懒汉式 :双重检测模式的懒汉单例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private LazyMan() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    //双重检测模式的懒汉单例，DCL懒汉式</span><br><span class="line">    public static LazyMan getInstance() &#123;</span><br><span class="line">        synchronized (LazyMan.class) &#123;</span><br><span class="line">            if (lazyMan == null) &#123;</span><br><span class="line">                lazyMan = new LazyMan();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazyMan;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码存在问题,需要避免指令重排:volatile</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private LazyMan() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile static LazyMan lazyMan;//禁止指令重排</span><br><span class="line"></span><br><span class="line">    //双重检测模式的懒汉单例，DCL懒汉式</span><br><span class="line">    public static LazyMan getInstance() &#123;</span><br><span class="line">        synchronized (LazyMan.class) &#123;</span><br><span class="line">            if (lazyMan == null) &#123;</span><br><span class="line">                lazyMan = new LazyMan();//不是一个原子性操作</span><br><span class="line">                //1.分配内存空间</span><br><span class="line">                //2.执行构造方法，初始化对象</span><br><span class="line">                //3.把这个对象指向这个空间</span><br><span class="line">                //正常123</span><br><span class="line">                //但如果走成1 3（期间单例B线程插入） 2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazyMan;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Holder()&#123;&#125;</span><br><span class="line">public static Holder getInstance()&#123;</span><br><span class="line">    return InnerClass.HOLDER;</span><br><span class="line">&#125;</span><br><span class="line">public static class InnerClass&#123;</span><br><span class="line">    private static final  Holder HOLDER=new Holder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单例不安全，反射可以破解</p>
</blockquote>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//enum是什么,本身也是一个class类</span><br><span class="line">public enum  EnumSingle &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public EnumSingle getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EnumSingle instance = EnumSingle.INSTANCE;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-深入理解CAS"><a href="#20-深入理解CAS" class="headerlink" title="20.深入理解CAS"></a>20.深入理解CAS</h3><blockquote>
<p>什么是CAS</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    //原子类的底层是CAS</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger=new AtomicInteger(2021);</span><br><span class="line">        //如果期望值达到了，就更新</span><br><span class="line">        //CAS是CPU的并发原理</span><br><span class="line">        atomicInteger.compareAndSet(2021,2022);//比较并交换</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CAS:比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则操作，如果不是就一值循环。</p>
<p>缺点：</p>
<p>1.循环耗时</p>
<p>2.一次只能保证一个共享变量的原子性</p>
<p>3.ABA问题</p>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>狸猫换太子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//原子类的底层是CAS</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       AtomicInteger atomicInteger=new AtomicInteger(2021);</span><br><span class="line">       //如果期望值达到了，就更新</span><br><span class="line">       //CAS是CPU的并发原理</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       //对于SQL来说，会有乐观锁解决</span><br><span class="line"></span><br><span class="line">       //======================捣乱的线程==============================</span><br><span class="line">       atomicInteger.compareAndSet(2021,2022);//比较并交换</span><br><span class="line">       System.out.println(atomicInteger.get());</span><br><span class="line">       atomicInteger.compareAndSet(2022,2021);//比较并交换</span><br><span class="line">       System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">       //=======================期望的线程============================</span><br><span class="line">       atomicInteger.compareAndSet(2021,2022);//比较并交换</span><br><span class="line">       System.out.println(atomicInteger.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>怎么解决，不被捣乱？</p>
<h3 id="21-原子引用"><a href="#21-原子引用" class="headerlink" title="21.原子引用"></a>21.原子引用</h3><p>带版本号的原子！</p>
<p>如果泛型是包装类，要注意对象的引用问题。</p>
<p><strong>Integer使用对象缓存机制，默认范围-128-127，推荐使用静态工厂方法valueof获取对象实例，而不是new，因为valueof使用缓存，而new一定会创建新的对象分配新的内存。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      AtomicStampedReference&lt;Integer&gt; atomicInteger = new AtomicStampedReference&lt;&gt;(1,1);</span><br><span class="line"></span><br><span class="line">      new Thread(()-&gt;&#123;</span><br><span class="line">          int stamp = atomicInteger.getStamp(); //获得版本号</span><br><span class="line">          System.out.println(&quot;a=&gt;&quot;+stamp);</span><br><span class="line"></span><br><span class="line">          System.out.println(atomicInteger.compareAndSet(1, 2, atomicInteger.getStamp(), atomicInteger.getStamp() + 1));</span><br><span class="line">          System.out.println(&quot;a2=&gt;&quot;+atomicInteger.getStamp());</span><br><span class="line"></span><br><span class="line">          System.out.println(atomicInteger.compareAndSet(2, 1, atomicInteger.getStamp(), atomicInteger.getStamp() + 1));</span><br><span class="line">          System.out.println(&quot;a3=&gt;&quot;+atomicInteger.getStamp());</span><br><span class="line"></span><br><span class="line">      &#125;,&quot;a&quot;).start();</span><br><span class="line"></span><br><span class="line">      new Thread(()-&gt;&#123;</span><br><span class="line">          int stamp = atomicInteger.getStamp(); //获得版本号</span><br><span class="line">          System.out.println(&quot;b=&gt;&quot;+stamp);</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              TimeUnit.SECONDS.sleep(2);</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.out.println(atomicInteger.compareAndSet(1, 6, atomicInteger.getStamp(), atomicInteger.getStamp() + 1));</span><br><span class="line">          System.out.println(&quot;b2=&gt;&quot;+atomicInteger.getStamp());</span><br><span class="line"></span><br><span class="line">      &#125;,&quot;b&quot;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决ABA问题，B线程把数据改变了又改回来，A线程不知情。</strong></p>
<p><strong>对应思想：乐观锁</strong></p>
<h3 id="22-各种锁的理解"><a href="#22-各种锁的理解" class="headerlink" title="22.各种锁的理解"></a>22.各种锁的理解</h3><h4 id="1-公平锁、非公平锁"><a href="#1-公平锁、非公平锁" class="headerlink" title="1.公平锁、非公平锁"></a>1.公平锁、非公平锁</h4><p>公平锁：非常公平，不能插队，线程必须先来后到！<br>非公平锁：非常不公平，可以插队（默认）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">        sync = new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-可重入锁-递归锁"><a href="#2-可重入锁-递归锁" class="headerlink" title="2.可重入锁(递归锁)"></a>2.可重入锁(递归锁)</h4><p>拿到外面的锁，就可以自动获取里面的锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone=new Phone();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Phone&#123;</span><br><span class="line">    public synchronized void sms()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;sms&quot;);</span><br><span class="line">        call();//这里也有锁</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void call()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;call&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone2 phone = new Phone2();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2 &#123;</span><br><span class="line">    Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void sms() &#123;</span><br><span class="line">        lock.lock();//细节问题：两把锁，lock锁必须配对，不然会死锁</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);</span><br><span class="line">            call();//这里也有锁</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void call() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;call&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3.自旋锁"></a>3.自旋锁</h4><p>spinlock</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//自旋锁</span><br><span class="line">public class SpinLock1 &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference=new AtomicReference&lt;&gt;();</span><br><span class="line">    //加锁</span><br><span class="line">    public void myLock()&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;==&gt;mylock&quot;);</span><br><span class="line">        while (atomicReference.compareAndSet(null,thread));//自旋锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解锁</span><br><span class="line">    public void myUnLock()&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;==&gt;myunlock&quot;);</span><br><span class="line">        atomicReference.compareAndSet(thread,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SpinLock1 spinLock = new SpinLock1();</span><br><span class="line"></span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           spinLock.myLock();</span><br><span class="line">           try &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(3);</span><br><span class="line">           &#125;catch (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;finally &#123;</span><br><span class="line">               spinLock.myUnLock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, &quot;T1&quot;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       new Thread(() -&gt; &#123;</span><br><span class="line">           spinLock.myLock();</span><br><span class="line">           try &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(1);</span><br><span class="line">           &#125;catch (Exception e)&#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;finally &#123;</span><br><span class="line">               spinLock.myUnLock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, &quot;T2&quot;).start();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h4><blockquote>
<p>死锁是什么？</p>
</blockquote>
<p>线程A抢线程B的锁，线程B抢线程A的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String lockA=&quot;lockA&quot;;</span><br><span class="line">        String lockB=&quot;lockB&quot;;</span><br><span class="line">        new Thread(new MyThread(lockA,lockB),&quot;T1&quot;).start();</span><br><span class="line">        new Thread(new MyThread(lockA,lockB),&quot;T2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String lockA;</span><br><span class="line">    private String lockB;</span><br><span class="line"></span><br><span class="line">    public MyThread(String lockA, String lockB) &#123;</span><br><span class="line">        this.lockA = lockA;</span><br><span class="line">        this.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;lock:&quot;+lockA+&quot;=&gt;get:&quot;+lockB);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;lock:&quot;+lockB+&quot;=&gt;get:&quot;+lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决问题（死锁排查）</p>
</blockquote>
<p>1.使用命令提示符命令，jps -l定位进程号</p>
<p>2.使用 jstack+进程号，找到死锁问题</p>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E9%AB%98%E7%BA%A7/JVM/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  JVM
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2021/12/02/JAVA%E5%AD%A6%E4%B9%A0/java%E9%AB%98%E7%BA%A7/Java%E6%B3%A8%E8%A7%A3/">
                Java注解
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2021-<span id="footerYear"></span> 
	<a href="/">小德</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>